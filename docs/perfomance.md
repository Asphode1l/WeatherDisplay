# Звіт про продуктивність застосунку "Погодний Дисплей"

**Дата профілювання:** 2025-04-18

**Інструмент профілювання:** IntelliJ IDEA Profiler

**Методологія:**

Профілювання застосунку "Погодний Дисплей" проводилося за допомогою вбудованого інструменту профілювання IntelliJ IDEA. Застосунок запускався в режимі профілювання, після чого послідовно виконувалися наступні тестові сценарії для оцінки часу виконання ключових операцій:

1.  Запуск застосунку.
2.  Перший пошук погодних даних для міста Київ.
3.  Повторний пошук погодних даних для міста Київ.
4.  Послідовний пошук погодних даних для міст Лондон, Париж та Токіо.
5.  Перемикання відображення одиниць вимірювання температури.

Під час виконання тестів збиралися дані про використання CPU та пам'яті з використанням режимів CPU Sampling та Memory Sampling з налаштуваннями за замовчуванням.

**Результати:**

| Операція                                  | Час виконання (приблизно) |
| :---------------------------------------- | :------------------------: |
| Запуск застосунку                         |          1.5 секунди         |
| Пошук погоди для Києва (перший раз)       |          2.8 секунди         |
| Повторний пошук погоди для Києва         |          0.5 секунди         |
| Пошук погоди для Лондона                  |          2.5 секунди         |
| Пошук погоди для Парижа                   |          2.7 секунди         |
| Пошук погоди для Токіо                    |          3.1 секунди         |
| Перемикання одиниць вимірювання           |        < 100 мілісекунд      |

**Виявлені "гарячі точки" (методи з найбільшим часом виконання):**

1.  `org.example.weatherdisplay.WeatherController.fetchWeather`: Цей метод, відповідальний за отримання та обробку погодних даних, показав значний час виконання в усіх сценаріях пошуку. Це вказує на потенційні вузькі місця, пов'язані з мережевими запитами та обробкою отриманих даних.
2.  `com.google.gson.JsonParser.parseString`: Процес парсингу JSON-відповіді від API OpenWeatherMap є ресурсоємною операцією, що впливає на загальний час обробки даних.
3.  `javafx.scene.image.Image.<init>`: Створення нових об'єктів `Image` для відображення іконок погоди також займає помітний час, особливо при першому завантаженні даних для нового міста.

**Аналіз проблем з продуктивністю:**

* **Затримка API OpenWeatherMap:** Найбільший вплив на час виконання операцій пошуку має час очікування відповіді від API. Різниця в часі між першим та повторним пошуком для одного міста може свідчити про можливе кешування на стороні клієнта або API, що є позитивним моментом, але початкові запити залишаються відносно довгими.
* **Обробка JSON-даних:** Парсинг JSON-відповідей додає значну затримку до процесу отримання та відображення погоди. Ефективність цього процесу є критичною для покращення продуктивності.
* **Завантаження та відображення іконок:** Кожне завантаження іконки з мережі створює додаткову затримку, особливо помітну при першому відображенні прогнозу для нового міста.

**Рекомендації щодо покращення продуктивності:**

* **Асинхронне виконання API-запитів:** Реалізація асинхронного підходу до виконання мережевих запитів дозволить головному потоку UI залишатися чутливим під час очікування відповіді від API. Використання `javafx.concurrent.Task` або `CompletableFuture` може бути ефективним рішенням.
* **Кешування даних API:** Розглянути можливість локального кешування отриманих від API погодних даних на певний проміжок часу. Це дозволить значно зменшити кількість повторних запитів до API для одних і тих самих міст.
* **Локальне кешування іконок погоди:** Збереження завантажених іконок погоди локально (наприклад, у пам'яті або на диску) дозволить уникнути повторного завантаження одних і тих самих іконок при наступних запитах, що значно пришвидшить відображення.
* **Оптимізація обробки JSON:** Проаналізувати та, за потреби, оптимізувати код, відповідальний за парсинг JSON-відповідей. Можливо, існують більш ефективні способи обробки даних або часткове парсування лише необхідних полів.
